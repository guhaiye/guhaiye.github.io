<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA['npm自定义组件打包发布过程']]></title>
    <url>%2F2020%2F11%2F16%2Fnpm%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、到npm官网(https://www.npmjs.com/)注册账号2、然后在cmd中执行登录命令：npm login 然后输入用户名，回车输入密码，回车输入邮件，回车新建一个文件夹，然后cd到这个文件夹3.1 在cmd中执行npm init依次按要求填好项目名称（name）、版本(version)、描述(descrition)（注意：取名字的时候，最好把你想取的名字到npm官网查查看有没有相同或者类似的包，不然发布的时候会一直提示你改的） 3.2 然后新建index.js入口文件，以及readme.md文件3.3 然后执行发布命令npm publish（如果没登录会出现以下提示:) 所以要执行npm login进行登录，登录完成后再执行发布命令：npm publish，结果又报错了：403 Forbidden - PUT http://registry.cnpmjs.org/nodetest11 - [no_perms] Private mode enable, only admin can publish this module 经过查询资料得知,我们登录的时候登的是cnpm！可以输入以下命令查看当前的登录源：npm config get registry 输入以下命令切回npmjs源：npm config set registry=http://registry.npmjs.org切换回来后需要再次登录，登录成功执行发布命令，哎呀 还是报错了：（注意：发布的时候360会弹窗阻止访问，记得点允许！）403 Forbidden - PUT http://registry.npmjs.org/nodetest11 - Package name too similar to existing packages; try renaming your package to ‘@liucfang/nodetest11’ and publishing with ‘npm publish –access=public’ instead 说是名字太相似了，要求改个名字，并且使用npm publish –access=public 发布好吧，那就改名字呗！尝试改了个带大写字母的名字，发布的时候果然报错了！如下： 所以包的名字不能包含大写字母？那就改成小写试试：哎呀妈，还是报错了，坑还真不少呢： 提示要核实邮箱，因为刚注册成功后，npm会往你注册的邮箱里发一个邮件，用来验证你的邮箱是否正确可用，所以要打开邮件核实，唉，漏了一步都不行呢！那就登录邮箱核实呗。 核实完后再次执行发布命令：npm publish –access=public好家伙，终于发布成功了：到npmjs官网查下看有没有，有了，完美！tip：发布完后可以新建一个项目（或在已有项目中安装使用），然后通过npm install nodecc11 下载该安装包，引入：var getSum = require(‘nodecc11’); 就可以调用getSum 进行求和啦！]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview和il8n不兼容的问题]]></title>
    <url>%2F2019%2F11%2F14%2Fiview%E5%92%8Cil8n%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Vue.use(iview, { i18n: (key,value)=&gt; { let val = i18n.t(key, value); if (val !== null &amp;&amp; val !== undefined) return value; return ‘’; }})]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试100道题]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95100%E9%81%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？ key的作用是更新组件时判断两个节点是否相同，相同就复用，不相同就删除旧的创建新的，key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。 2、[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? 答案是[1, NaN, NaN] parseInt(‘1’, 0) //基数为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1 parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN 3、什么是防抖和节流？有什么区别？如何实现？ 防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间 思路：每次触发事件时都取消之前的延时调用方法 function debounce(fn){ let timeout = null; return function(){ clearTimeout(timeout) timeout = setTimeout(() =&gt; { fn.apply(this,arguments) },500) } } function sayHi(){ console.log(‘防抖成功’) } var inp = document.getElementById(‘inp’); inp.addEventListener(‘input’,debounce(sayHi)) 节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 思路：每次触发事件时都判断当前是否有等待执行的延时函数 function throttle(fn){ let canRun = true; return function(){ if(!canRun) return; canRun = false; setTimeout(()=&gt;{ fn.apply(this,arguments); canRun = true; },500) } } function sayHi(e) { console.log(e.target.innerWidth, e.target.innerHeight); } window.addEventListener(‘resize’,throttle(sayHi)) 4、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？ Set: 1、成员不能重复 2、只有键值，没有键名，有点类似数组 3、可以遍历，方法有add,delete,has ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。 WeakSet: 1、成员都是对象 2、成员都是弱引用，随时可以消失，可以用来保存DOM节点，不容易造成内存泄漏 3、不能遍历，方法有add,delete,has Map: 1、本质上是键值对的集合，类似集合 2、可以遍历，方法很多，可以跟各种数据格式转换 WeakMap: 1、直接受对象作为健名（null除外），不接受其他类型的值作为健名 2、健名所指向的对象，不计入垃圾回收机制 3、不能遍历，方法同get,set,has,delete 5、介绍下深度优先遍历和广度优先遍历，如何实现？ 深度优先遍历DFS 与树的先序遍历比较类似：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止 广度优先遍历 BFS：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 6、请分别用深度优先思想和广度优先思想实现一个拷贝函数？ 暂留位置 7、ES5/ES6 的继承除了写法以外还有什么区别？ ES5是先创建子类再在父类添加这个方法 ES6是创建子类直接继承父类 8、setTimeout、Promise、Async/Await 的区别 a、setTimeout：延时执行函数 console.log(&apos;script start&apos;) //1. 打印 script start setTimeout(function(){ console.log(&apos;settimeout&apos;) // 4. 打印 settimeout }) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数 console.log(&apos;script end&apos;) //3. 打印 script start // 输出顺序：script start-&gt;script end-&gt;settimeout b、Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。 console.log(&apos;script start&apos;) let promise1 = new Promise(function (resolve) { console.log(&apos;promise1&apos;) resolve() console.log(&apos;promise1 end&apos;) }).then(function () { console.log(&apos;promise2&apos;) }) setTimeout(function(){ console.log(&apos;settimeout&apos;) }) console.log(&apos;script end&apos;) // 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout c、async/await：async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async async function async1(){ console.log(‘async1 start’); await async2(); console.log(‘async1 end’) } async function async2(){ console.log(‘async2’) } console.log(&apos;script start&apos;); async1(); console.log(&apos;script end&apos;) // 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 9、Async/Await 如何通过同步的方式实现异步 暂留空位 10、（头条）异步笔试题 //请写出输出内容 async function async1() { console.log(‘async1 start’); await async2(); console.log(‘async1 end’); } async function async2() { console.log(‘async2’); } console.log(&apos;script start&apos;); setTimeout(function() { console.log(&apos;setTimeout&apos;); }, 0) async1(); new Promise(function(resolve) { console.log(&apos;promise1&apos;); resolve(); }).then(function() { console.log(&apos;promise2&apos;); }); console.log(&apos;script end&apos;); /* script start async1 start async2 promise1 script end async1 end promise2 setTimeout */ 11、编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; Array.from(new Set(arr.flat(Infinity))).sort((a,b)=&gt;{ return a-b}) 12、JS 异步解决方案的发展历程以及优缺点 a、回调函数（callback） 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 优点：解决了同步的问题 ajax(&apos;XXX1&apos;, () =&gt; { // callback 函数体 ajax(&apos;XXX2&apos;, () =&gt; { // callback 函数体 ajax(&apos;XXX3&apos;, () =&gt; { // callback 函数体 }) }) }) b、Promise Promise就是为了解决callback的问题而产生的。 缺点：无法取消 Promise ，错误需要通过回调函数来捕获 优点：解决了回调地狱的问题 ajax(‘XXX1’) .then(res =&gt; { // 操作逻辑 return ajax(‘XXX2’) }).then(res =&gt; { // 操作逻辑 return ajax(‘XXX3’) }).then(res =&gt; { // 操作逻辑 }) let p1 = new Promise((resolve, reject) =&gt; { resolve(&apos;成功了&apos;) }) let p2 = new Promise((resolve, reject) =&gt; { resolve(&apos;success&apos;) }) Promise.all([p1, p2]).then((result) =&gt; { console.log(result) //[&apos;成功了&apos;, &apos;success&apos;] }).catch((error) =&gt; { console.log(error) }) c、Generator 特点：可以控制函数的执行，可以配合 co 函数库使用 function *fetch() { yield ajax(‘XXX1’, () =&gt; {}) yield ajax(‘XXX2’, () =&gt; {}) yield ajax(‘XXX3’, () =&gt; {}) } let it = fetch() let result1 = it.next() let result2 = it.next() let result3 = it.next() d、Async/await 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch(‘XXX1’) await fetch(‘XXX2’) await fetch(‘XXX3’) } 13、Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？ promise构造函数是同步执行的，then方法是异步执行的 14、如何实现一个 new（暂留位置） 15、简单讲解一下http2的多路复用 简单来说，就是在同一个tcp连接，同一个时刻可以传输多个http请求 HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。 HTTP2中同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰 16、谈谈你对TCP三次握手和四次挥手的理解 三次握手： client：你好，我是A server：收到，我是B client：那咱们可以连接了 四次挥手 client：你好，我要关了 server：稍等，还有一个包 server：我已好，随时可以关闭 client：关闭吧，不用回复 17、A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 因为B会在重启之后进入tcp状态机的listen状态，只要当a重新发送一个数据包（无论是syn包或者是应用数据）b和a沟通过程双方有一份数据， b重启之后这份数据没有了，就会发送rst重置，b端应该会主动发送一个带rst位的重置包来进行连接重置，所以a应该在syn_sent状态（请求连接状态） 18、React 中 setState 什么时候是同步的，什么时候是异步的？ 如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。 19、React setState 笔试题，下面的代码输出什么？ class Example extends React.Component { constructor() { super(); this.state = { val: 0 }; } componentDidMount() { this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 1 次 log：输出0 this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 2 次 log：输出0 setTimeout(() =&gt; { this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 3 次 log：输出2 this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 4 次 log：输出3 }, 0); } render() { return null; } }; 1、第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 true，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。 2、两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 1。 3、setTimeout 中的代码，触发时 isBatchingUpdates 为 false，所以能够直接进行更新，所以连着输出 2，3。 20、介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 1、执行工程自身 preinstall 2、确定首层依赖模块 3、获取模块 4、模块扁平化（dedupe） 5、安装模块 6、执行工程自身生命周期 21、有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 a、Object.prototype.toString.call() 每一个继承Object的对象都有toString方法，如果toString方法没有被重写的话，会返回[Object type],其中type为对象的类型，但当除了Object的类型的对象外，其他类型直接使用toString方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文 const an = [‘111’,’333’] an.toString() Object.prototype.toString.call(an) b、instanceof 是通过判断对象的原型链中是不是能找到类型的prototype [] instanceof Array c、Array.isArray() 功能：用来判断对象是否为数组 Array.isArray(arr); 22、介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化 a、浏览器渲染机制 浏览器采用流式布局模型 浏览器会把HTML解析成DOM，把css解析成CSSOM，DOM和CSSOM合并就产生了渲染树 有了渲染树，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到界面上 浏览器使用流式布局，对渲染树的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，故避免使用table布局 b、重绘 由于节点的集合属性发生改变或者由于样式发生改变而不影响布局的，称为重绘，例如：outline，visibility，color，backgroundcolor等 c、回流 是布局或者集合属性需要改变就发生回流，回流是影响浏览器性能的关键因素 回流必然会发生重绘，重绘不一定发生回流 浏览器优化 浏览器大多是通过队列机制来批量更新布局，浏览器会把修改操作放在队列里，至少浏览器刷新才会清空队列，但当你获取布局信息的时候队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值 23、介绍下观察者模式和发布-订阅模式的区别，各自适用于什么场景 观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知 发布-订阅模式就好像报社，邮局和个人的关系，报纸的订阅和分发是由邮局来完成的，报局只负责将报纸发送给邮局 观察者模式就好像个体奶农和个人的关系，奶农负责统计有多少人订了产品，所以个人都会有一个相同拿牛奶的方法，奶农有新奶了就负责调用这个方法 24、聊聊 Redux 和 Vuex 的设计思想 共同点：两者都是处理全局状态的工具库，大致实现思想是：全局state保存状态–&gt;dispatch(action)–&gt;reducer(vuex里面的mutaion)–&gt;生成new state,整个状态为同步操作 区别：最大的区别是处理异步的不同，vuex里面多了一步commit操作，在action之后commit(mutation)之前处理异步，而redux里面则是通过中间件处理 25、浏览器和Node 事件循环的区别 其中一个区别是浏览器的event loop和nodejs的event loop在处理异步事件的顺序是不同的，nodejs中有micro event，其中promise属于micro event该异步事件的处理顺序就和浏览器不同，nodejs V11.0以上，这两者之间的顺序就相同了 26、介绍模块化发展历程 模块化主要用来抽离公共代码，隔离作用域，避免变量冲突等 IIFE：使用自执行函数来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突 (function(){ return { data: [] } }) AMD:使用requireJS来编写模块化，特点：依赖必须提前声明好 define(‘./index.js’,function(code){ //code就是index.js返回的内容 }) CMD:使用seaJS来编写模块化，特点：支持动态引入依赖文件 define(function(require, exports, module) { var indexCode = require(‘./index.js’); }); CommonJs:nodejs中自带的模块化 var fs = require(‘fs’); UMD:兼容AMD,CommonJs模块化语法 webpack(require.ensure):webpack 2.x中的代码分割 ES Modules:ES6引入的模块化，支持import来引入另一个js import a from ‘a’ 27、var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 属于块级作用域 28、cookie 和 token 都存放在 header 中，为什么不会劫持 token？ a、首先token不是防止xss的，而是为了防止csrf的 b、csrf攻击的原因是浏览器会自动带上cookie，而浏览器不会自动带上token 29、聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的 M-&gt;V：（data binding）这样可以大量节省你人肉来update View的代码 V-&gt;M：（DOM listeners）这样你的modal会随着view触发事件而改变 a、Object.defineProperty方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象 b、observe的功能就是用来检测数据的变化，实现方式是给非VNode的对象类型数据添加一个Observer,对象已经添加过则直接返回，否则在满足一定条件下去实例化一个Observer对象实例 30、两个数组合并成一个数组 请把俩个数组 [A1, A2, B1, B2, C1, C2, D1, D2] 和 [A, B, C, D]，合并为 [A1, A2, A, B1, B2, B, C1, C2, C, D1, D2, D]。 const a = [A1, A2, B1, B2, C1, C2, D1, D2] const prefix = [A, B, C, D] prefix.map(p =&gt; { res = res.concat(a.filter(s =&gt; s.indexOf(p)),p) }) 31、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。 for (var i = 0; i&lt; 10; i++){ setTimeout(() =&gt; { console.log(i); }, 1000) } 32、Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。 这是一个性能 VS 可维护性的取舍，框架的意义在于为你掩盖底层的DOM操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护，没有任何框架可以比纯手动的优化DOM操作更快，因为框架的DOM操作层需要应对任何上层API可能产生的操作，它的实现必须是普适的 总结：主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个 33、下面的代码打印什么内容，为什么？ var b = 10; (function b(){ b = 20; console.log(b); })(); 打印出来是b(){} 34、简单改造上面的代码，使之分别打印 10 和 20。 35、浏览器缓存读取规则 36、使用迭代的方式实现 flatten 函数。 let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]] const flatten = function (arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(…arr) } return arr } console.log(flatten(arr)) ES6简写： const flatten = array =&gt; array.reduce((acc, cur) =&gt; (Array.isArray(cur) ? […acc, …flatten(cur)] : […acc, cur]), []) 37、为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？ a、Mutation 必须是同步函数 b、更改state的函数必须是纯函数，纯函数既是统一输入就会统一输出，没有任何副作用，如果是异步则会引入额外的副作用，导致更改后的state不可预测 38、下面代码中 a 在什么情况下会打印 1？ var a = ?; if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){ console.log(1); } 此题考查的是==的隐式类型转换 第一种： var a = { i: 1, toString() { return a.i++; } } if( a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 ) { console.log(1); } 第二种： var a = Object.create({ count: 0, valueOf: function() { return ++this.count; } }); if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) { console.log(1); } 39、介绍下 BFC 及其应用 BFC就是块级格式上下文，是页面盒模型布局中的一种css渲染模式，相当于一个独立容器，里面的元素和外面的元素相互不影响，创建BFC的方式有： a、html根元素 b、float浮动 c、绝对定位 d、overflow不是visible e、display为表格布局或者弹性布局 BFC主要的作用是： 1、清除浮动 2、防止同一BFC容器中的相邻元素间的外边距重叠问题 40、在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的 a、子组件为何不可以修改父组件传递的 Prop？ 单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。 b、如果修改了，Vue 是如何监控到属性的修改并给出警告的。 下面的代码就是实现Vue提示修改props的操作，在组件 initProps 方法的时候，会对props进行defineReactive操作，传入的第四个参数是自定义的set函数，该函数会在触发props的set方法时执行，当props修改了，就会运行这里传入的第四个参数，然后进行判断，如果不是root根组件，并且不是更新子组件，那么说明更新的是props，所以会警告 41、下面代码输出什么？ var a = 10; (function () { console.log(a) a = 5 console.log(window.a) var a = 20; console.log(a) })() undefined -&gt; 10 -&gt; 20 42、实现一个 sleep 函数 // 方法一 function sleep(time) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(time) }, time) }) } sleep(5000).then((time) =&gt; { console.log(`你睡了${time / 1000}s，然后做你的事情`) }) // 方法二 function async sleep2(time) { await sleep(time) // then do you thing console.log(`你睡了${time / 1000}s，然后做你的事情`) // async 函数返回的是一个promise对象 } // 方法三 // 通过generator 还是返回一个promise，这个不知道具体的意义,这和返回一个普通的promise有区别么 function* sleep3(time) { yield new Promise(resolve =&gt; { setTimeout(resolve, time) }) } sleep3(5000).next().value.then(() =&gt; { console.log(&quot;睡了一会儿，然后做你做的事情&quot;)}) // 方法四 // 通过传统的setTimeout去做 function sleep4(func, time) { setTimeout(func, time) } 43、使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果 var arr = [3, 15, 8, 29, 102, 22]; arr.sort() 输出结果：[102, 15, 22, 29, 3, 8] 根据MDN上的解释，默认的排序方式会将数组元素转换为字符串，然后比较字符串中字符UTF-16编码顺序来进行排序，所以‘102’会排在‘15’前面 44、介绍 HTTPS 握手过程 a、客户端使用https的url访问web服务器，要求与服务器建立ssl连接 b、web服务器收到客户端请求后，会将网站的证书（包含密钥）传送一份给客户端 c、客户端收到网站证书后会检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个密钥 d、客户端利用公钥将会话密钥加密，并传送给服务端，服务端利用自己的私钥解密解密出会话密钥 e、之后服务器和客户端使用密钥加密传输 45、HTTPS 握手过程中，客户端如何验证证书的合法性 a、校验证书的颁发机构是否受客户端信任。 b、通过 CRL 或 OCSP 的方式校验证书是否被吊销。 c、对比系统时间，校验证书是否在有效期内。 d、通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。 46、输出以下代码执行的结果并解释为什么 var obj = { ‘2’: 3, ‘3’: 4, ‘length’: 2, ‘splice’: Array.prototype.splice, ‘push’: Array.prototype.push } obj.push(1) obj.push(2) console.log(obj) 类数组（ArrayLike）： 一组数据，由数组来存，但是如果要对这组数据进行扩展，会影响到数组原型，ArrayLike的出现则提供了一个中间数据桥梁，ArrayLike有数组的特性， 但是对ArrayLike的扩展并不会影响到原生的数组。 题分析： 这个obj中定义了两个key值，分别为splice和push分别对应数组原型中的splice和push方法，因此这个obj可以调用数组中的push和splice方法，调用对象的push方法：push(1)，因为此时obj中定义length为2，所以从数组中的第二项开始插入，也就是数组的第三项（下表为2的那一项），因为数组是从第0项开始的，这时已经定义了下标为2和3这两项，所以它会替换第三项也就是下标为2的值，第一次执行push完，此时key为2的属性值为1，同理：第二次执行push方法，key为3的属性值为2。此时的输出结果就是：Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ] 如果题中的length改成0 则结果会变成Object(2) [1, 2, 2: 3, 3: 4, splice: ƒ, push: ƒ] 47、双向绑定和 vuex 是否冲突 在严格模式下使用vuex，当用户输入时，v-model会直接试图修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误，当需要在组件中使用vuex的state时，有2种解决方案 a、在input中绑定value（vuex中的state）然后监听input的change事件或者input事件，在事件回调中调用mutation修改state的值 b、使用带有setter的双向绑定计算属性 48、call 和 apply 的区别是什么，哪个性能更好一些 作用是一样的，区别在于传入参数的不同 第一个参数是：指定函数体内this的指向 第二个参数开始不同，apply是传入带下标的集合，数组或者类数组，apply是把它传给函数作为参数，call从第二个参数开始是不固定的，都会传给函数作为参数 call比apply的性能要好，平常可以多用call，call传入参数格式正是内部所需要的格式 49、什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？ 50、（百度）实现 (5).add(3).minus(2) 功能 Number.prototype.add = function(n){ console.log(this.valueOf()) return this + n } Number.prototype.minus = function(n){ return this - n } console.log((5).add(3).minus(2)) 51、Vue 的响应式原理中 Object.defineProperty 有什么缺陷？ a、Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应 b、Object.defineProperty只能劫持对象的属性从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历，proxy可以劫持整 个对象，并返回一个新的对象 c、proxy不仅可以代理对象，还可以代理数组，还可以代理动态增加的属性 proxy有以下优点： 可以劫持整个对象，并返回一个新对象 有13种劫持操作 52、怎么让一个 div 水平垂直居中 53、输出以下代码的执行结果并解释为什么 var a = {n: 1}; var b = a; a.x = a = {n: 2}; console.log(a.x) console.log(b.x) 结果: undefined {n:2} 首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是运用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。 后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。 54、冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？ 时间复杂度：O(n^2) 55、某公司 1 到 12 月份的销售额存在一个对象里面，如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。 let obj = {1:222, 2:123, 5:888}; obj.length = 12; let _obj = Array.from(obj).slice(1); let newObj = _obj.map((item) =&gt; {if(item === undefined) {return null;} else {return item;}}); console.log(newObj); 56、要求设计 LazyMan 类，实现以下功能 57、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。 58、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？ 箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异： 1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 4、不可以使用 new 命令，因为没有自己的 this，无法调用 call，apply。 没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 __proto__ 59、给定两个数组，写一个方法来计算它们的交集。 let num1 = [1, 2, 2, 1],num2 = [2, 2]; let newarr = num2.filter((item)=&gt;{ return num1.includes(item) }) return newarr; 60、已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。 &lt;img src=&quot;1.jpg&quot; style=&quot;width:480px!important;”&gt; 61、介绍下如何实现 token 加密 JWT 62、redux 为什么要把 reducer 设计成纯函数 redux的设计思想就是不产生副作用，数据更改的状态可回溯，所以redux中处处都是纯函数 63、如何设计实现无缝轮播 64、模拟实现一个 Promise.finally Promise.prototype.finally = function(callback){ let p = this.constructor; return this.then( value =&gt; p.resolve(callback()).then(()=&gt;value), reason =&gt; p.resolve(callback()).then(() =&gt; {throw reason}) ); } 65、a.b.c.d 和 a[‘b’][‘c’][‘d’]，哪个性能更高？ 前一个比后一个性能高一些：后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。 66、ES6 代码转成 ES5 代码的实现思路是什么 题目说的是ES6,所以不考虑.jsx,.ts这类js扩展语言 ES6转ES5目前行业标配是Babel,转换的大致流程如下： a、解析：解析代码字符串，生成AST b、转换：将一定的规则转换，修改AST c、生成：将修改后的AST转换成普通代码 67、随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。 //随机生成长度为10的数组 function randomNumber(len) { const max = 20; const arr = []; for (let i = 0; i &lt; len; i++) { arr.push(Math.floor(Math.random() * max)); } const sorted = [...new Set(arr)].sort((a, b) =&gt; a - b); // 去重排序 return sorted; } //排序成新的数组 function sort(arr) { let dict = {}; let length = 0; arr.forEach(i =&gt; { let key = Math.floor(i / 10); if (Reflect.has(dict, key)) { dict[key].push(i); } else { dict[key] = [i]; length++; } }); dict.length = length; return Array.from(dict); } const res = randomNumber(10); console.log(sort(res)); 68、如何解决移动端 Retina 屏 1px 像素问题 a、解决方案是通过 JavaScript 检测浏览器能否处理0.5px的边框，如果可以，给html标签元素添加个class。 if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) { var testElem = document.createElement(&apos;div&apos;); testElem.style.border = &apos;.5px solid transparent&apos;; document.body.appendChild(testElem); } if (testElem.offsetHeight == 1) { document.querySelector(&apos;html&apos;).classList.add(&apos;hairlines&apos;); } document.body.removeChild(testElem); } 然后，极细的边框样式就容易了： div { border: 1px solid #bbb; } .hairlines div { border-width: 0.5px; } b、使用border-image实现 .border-image-1px { border-bottom: 1px solid #666; } @media only screen and (-webkit-min-device-pixel-ratio: 2) { .border-image-1px { border-bottom: none; border-width: 0 0 1px 0; -webkit-border-image: url(../img/linenew.png) 0 0 2 0 stretch; border-image: url(../img/linenew.png) 0 0 2 0 stretch; } } c、使用background-image实现 .background-image-1px { background: url(../img/line.png) repeat-x left bottom; -webkit-background-size: 100% 1px; background-size: 100% 1px; } d、多背景渐变实现 .background-gradient-1px { background: linear-gradient(#000, #000 100%, transparent 100%) left / 1px 100% no-repeat, linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100% no-repeat, linear-gradient(#000,#000 100%, transparent 100%) top / 100% 1px no-repeat, linear-gradient(#000,#000 100%, transparent 100%) bottom / 100% 1px no-repeat } /* 或者 */ .background-gradient-1px{ background: -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) left / 1px 100% no-repeat, -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) right / 1px 100% no-repeat, -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) top / 100% 1px no-repeat, -webkit-gradient(linear, left top, right bottom, color-stop(0, transparent), color-stop(0, #000), to(#000)) bottom / 100% 1px no-repeat } e、使用box-shadow模拟边框 .box-shadow-1px { box-shadow: inset 0px -1px 1px -1px #c8c7cc; } f、viewport + rem 实现 在devicePixelRatio = 2 时，输出viewport： &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt; 69、 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC&apos; 变成 &apos;aBc&apos; function processString(s){ var arr = s.split(&apos;&apos;); var new_arr = arr.map((item)=&gt;{ return item === item.toUpperCase()?item.toUpperCase:item.toLowerCase() }) return new_arr.join(&apos;&apos;); } 70、介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的 a.当修改了一个或多个文件； b.文件系统接收更改并通知webpack； c.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新； d.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp； e.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。 71、实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置 const find = (S,T) =&gt; S.indexOf(T) 72、为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因 73、介绍下 BFC、IFC、GFC 和 FFC bfc: 块级格式化上下文 display:block; ifc: 内联格式化上下文 display:inline; gfc：网格格式化上下文 display: grid ffc: 弹性格式化上下文 display: flex 74、使用 JavaScript Proxy 实现简单的数据绑定 75、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少 数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1) 消耗时间几乎一致，差异可以忽略不计 76、输出以下代码运行结果 // example 1 var a={}, b=&apos;123&apos;, c=123; a[b]=&apos;b&apos;; a[c]=&apos;c&apos;; //c的键名会被替换成字符串‘123’,会把b覆盖掉 console.log(a[b]); //输出c --------------------- // example 2 var a={}, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;); a[b]=&apos;b&apos;; //都是symbol类型 a[c]=&apos;c&apos;; //都是symbol类型,不会覆盖b console.log(a[b]); //输出b --------------------- // example 3 var a={}, b={key:&apos;123&apos;}, c={key:&apos;456&apos;}; a[b]=&apos;b&apos;; // 对象类型会调用 toString 方法转换成字符串 [object Object] a[c]=&apos;c&apos;; // 对象类型会调用 toString 方法转换成字符串 [object Object],覆盖b console.log(a[b]); //输出c 解题思路： a、对象的键名只能是字符串和symbol类型，symbol类型：表示独一无二的值，symbol最大的用途是用来定义对象的唯一属性名，可以作为对象属性的标识符使用 b、其它类型的键名会被转换成字符串类型 c、对象转字符串会默认调用toString方法 77、给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例： 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3 输出: [5, 6, 7, 1, 2, 3, 4] 解释: 向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6] 向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5] 向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4] 解题思路： function rotate(arr,k){ const len = arr.length; const step = k%len //可能步数比数组的长度长 return arr.slice(step).concat(arr.slice(0,len-step)); } 78、Vue 的父组件和子组件生命周期钩子执行顺序是什么 父组建： beforeCreate -&gt; created -&gt; beforeMount 子组件： -&gt; beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted 父组件： -&gt; mounted 总结：从外到内，再从内到外 79、input 搜索如何防抖，如何处理中文输入 80、介绍下 Promise.all 使用、原理实现及错误处理 Promise.all接收一个数组作为参数，p1,p2,p3都是promise实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理（Promise.all的参数可以不是数组，但必须是interator接口，且返回的每个成员都是Promise实例） 81、打印出 1 - 10000 之间的所有对称数 例如：121、1331 等 [...Array(10000).keys()].map(x=&gt;x+1).filter(x=&gt;{ return x.toString().length &gt; 1 &amp;&amp; x === Number(x.toString().split(&apos;&apos;).reverse().join(&apos;&apos;)) }) 82、算法题「移动零」，给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序 let nums = [0,0,0,3,12]; function zeroMove(array) { let len = array.length; let j = 0; for(let i=0;i&lt;len-j;i++){ if(array[i]===0){ array.push(0); array.splice(i,1); i --; j ++; } } return array; } 83、var,let 和 const 区别的实现原理是什么 let,const和var都存在变量提升 var 和 let 用以声明变量，const 用于声明只读的常量； var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效； let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用； let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。 let 不允许在相同作用域内，重复声明同一个变量； const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明； 84、请实现一个 add 函数，满足以下功能 add(1); // 1 add(1)(2); // 3 add(1)(2)(3)； // 6 add(1)(2, 3); // 6 add(1, 2)(3); // 6 add(1, 2, 3); // 6 function add(){ let args = [].slice.call(arguments); // Array.prototype.slice.call(arguments),arguments的call给slice就可以变成数组 let fn = function(){ let fn_args = [].slice.call(arguments); return add.apply(null,args.concat(fn_args)) } fn.toString = function(){ return args.reduce((a,b)=&gt;a+b) //方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 } return fn; } var arr = add(1,2)(3)(4) 85、react-router 里的 &lt;Link&gt; 标签和 &lt;a&gt; 标签有什么区别 &lt;Link&gt;是react-router实现路由跳转的连接，一般配合&lt;Route&gt;使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，&lt;Link&gt;的跳转行为只会触发相匹配的&lt;Route&gt;对应的页面内容更新，而不会刷新整个页面 而&lt;a&gt;标签就是普通的超链接了，用于从当前页面跳转到href指向的另一个页面（非锚点情况） 86、给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] var twoSum = function(nums, target) { const res = [] loop: for (let i =0; i&lt;nums.length-1; i++){ for (let j = i+1;j&lt;nums.length;j++){ if (nums[i]+nums[j]===target){ res.push(i,j) break loop } } } return res }; let nums = [2, 7, 11, 15]; var num = twoSum(nums,13); console.log(num) 87、在输入框中如何判断输入的是一个正确的网址 let url = &apos;https://www.baidu.com&apos;; function searchUrl(url) { try { if (new URL(url) &amp;&amp; (new URL(url).protocol === &quot;http:&quot; || new URL(url).protocol === &quot;https:&quot;) &amp;&amp; url.match(new RegExp(new URL(url).protocol + &quot;//&quot;)).index === 0) return true } catch (err) { console.log(&quot;不是一个正确的网址&quot;); } }; console.log(searchUrl(url)) 88、实现 convert 方法，把原始 list 转换成树形结构，要求尽可能降低时间复杂度 用递归的方式 function convert(source,parentId = 0){ let trees = []; for(let item of source){ if(item.parentId === parentId){ let children = convert(source,item.id); if(children.length){ item[&apos;children&apos;] = children } trees.push(item) } } return trees; } 89、设计并实现 Promise.race() 90、实现模糊搜索结果的关键词高亮显示 let panter = new RegExp(关键词, &apos;g&apos;) 该行字符串.replace(panter, &apos;&lt;b style=&quot;color: #2D7BFF&quot;&gt;&apos; + 关键词 + &apos;&lt;/b&gt;&apos;) 91、介绍下 HTTPS 中间人攻击 中间人攻击过程如下： a、服务器向客户端发送公钥。 b、攻击者截获公钥，保留在自己手上。 c、然后攻击者自己生成一个【伪造的】公钥，发给客户端。 d、客户端收到伪造的公钥后，生成加密hash值发给服务器。 e、攻击者获得加密hash值，用自己的私钥解密获得真秘钥。 f、同时生成假的加密hash值，发给服务器。 g、服务器用私钥解密获得假秘钥。 h、服务器用假秘钥加密传输信息 防范方法： 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性 92、已知数据格式，实现一个函数 fn 找出链条中所有的父级 id const data = [{ id: &quot;1&quot;, name: &quot;test1&quot;, children: [ { id: &quot;12&quot;, name: &quot;test12&quot;, children: [ { id: &quot;121&quot;, name: &quot;test121&quot; }, { id: &quot;122&quot;, name: &quot;test122&quot; } ] }, { id: &quot;11&quot;, name: &quot;test11&quot;, children: [ { id: &quot;111&quot;, name: &quot;test111&quot; }, { id: &quot;112&quot;, name: &quot;test112&quot; } ] }, ] }]; function fn (value) { const result = []; const dfs = (source) =&gt; { for (let item of source) { result.push(item); if (item.id === value) { return; } else { const res = dfs(item.children || []); if (!res) return; } console.log(result) result.pop(); } return true; }; dfs(data); // console.log(result) return result.map(item =&gt; item.id); } fn(&quot;112&quot;) // [&quot;1&quot;, &quot;11&quot;, &quot;112&quot;] 93、给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log(m+n)) var findMedianSortedArrays = function(num1,num2){ let num = num1.concat(num2) num = num.sort((a,b)=&gt;{a-b}) let mid = Math.floor(num.length)/2; if(num.length%2 == 0){//偶数个数 return (num[mid-1]+num[mid])/2 }else{ return num[mid] } } 94、vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？ 不需要，因为vue源码里已经做了处理，之前好像看过vue等框架都自己实现了一套事件,把事件都代理到document上面了,所以不需要自己手动再去代理了,如果不用框架需要代理到父级元素 95、模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况 96、介绍下前端加密的常见场景和方法 使用 PlanA-前端加密、后端解密后计算密码字符串的MD5/MD6存入数据库；也可以PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行MD5/MD6，全程密码明文不出现在程序中。 PlanA：使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6 PlanB：直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 。 97、React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？ 98、（京东）写出如下代码的打印结果 function changeObjProperty(o) { o.siteUrl = &quot;http://www.baidu.com&quot; o = new Object() // 形参 o 的指向发生改变，指向堆内存中一个新的对象 o.siteUrl = &quot;http://www.google.com&quot; } let webSite = new Object(); changeObjProperty(webSite); console.log(webSite.siteUrl); //&quot;http://www.baidu.com&quot; 99、（bilibili）编程算法题 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。 function reverse(bl){ var bl = bl.toString().split(&apos;&apos;); var bl2 = bl.reverse(); var str = bl2.join(&apos;&apos;).toString() console.log(str); console.log(typeof str) } reverse(1234) 100、（京东）请写出如下代码的打印结果 function Foo() { Foo.a = function() { console.log(1) } this.a = function() { console.log(2) } } Foo.prototype.a = function() { console.log(3) } Foo.a = function() { console.log(4) } Foo.a(); //4 let obj = new Foo(); obj.a(); //2 Foo.a(); //1 解题分析： function Foo() { Foo.a = function() { console.log(1) } this.a = function() { console.log(2) } } // 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行 Foo.prototype.a = function() { console.log(3) } // 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3 Foo.a = function() { console.log(4) } // 现在在 Foo 上挂载了直接方法 a ，输出值为 4 Foo.a(); // 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以 // # 输出 4 let obj = new Foo(); /* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事： 1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。 2. 在新对象上挂载直接方法 a ，输出值为 2。 */ obj.a(); // 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a， // # 输出 2 Foo.a(); // 构建方法里已经替换了全局 Foo 上的 a 方法，所以 // # 输出 1]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发应知网站]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%94%E7%9F%A5%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[作为一名前端开发者（所有程序员）最起码遇到bug就算不会解决也应该会搜解决问题的答案。 1、一般笔者会先在百度搜（关键词一定要输入正确）2、如果没搜到会再去bing里面看看3、还没有的话就去github的Issues里面再看看4、如果还不行就只能自己去看官方文档然后自己研究了。 下面一些链接是一些经常可以用到的网站，以此分享给大家1、MDN开发者文档：https://developer.mozilla.org/zh-CN/2、菜鸟教程：https://www.runoob.com/3、W3CSchool：http://www.w3school.com.cn/4、JavaScript教程网：https://zh.javascript.info/5、一行代码搞定bug监控：https://www.fundebug.com/?tdsourcetag=s_pcqq_aiomsg6、web开发人员必备工具包（实现快速敲代码）:https://docs.emmet.io/7、让代码提交的时候先执行一次代码，如果有报错不让提交：www.npmjs.com/package/eslint-config-airbnb8、阿里巴巴图标库：https://www.iconfont.cn/9、UI颜色布料：https://www.materialui.co/colors10、UI必备颜色表（色块+色码）:https://blog.csdn.net/weixin_43606158/article/details/9756917611、logo在线制作，有很多：http://www.logofree.cn/12、在线开发工具：https://tool.lu/c/developer13、项目部署流程：https://cloud.tencent.com/developer/information/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A412、谷歌浏览器插件下载地址： http://chromecj.com/13、网站SEO： http://www.jj3721.com/14、前端开发必备JS功能函数总结（上）：https://blog.csdn.net/weixin_43606158/article/details/9459047415、前端开发必备JS功能函数总结（下）：https://blog.csdn.net/weixin_43606158/article/details/9466040216、渐进式web应用程序核对表：https://developers.google.cn/web/progressive-web-apps/checklist17、在线存放图片的地址：https://sm.ms/18、代码变漂亮图片：https://carbon.now.sh19、MintUI：https://mint-ui.github.io/#!/zh-cn20、ElementUI：https://element.eleme.cn/#/zh-CN21、iViewUI：https://www.iviewui.com/22、Layui：https://www.layui.com/23、cubeUI：https://didi.github.io/cube-ui/#/zh-CN24、Antd：https://ant.design/index-cn25、MUI：http://dev.dcloud.net.cn/mui/26、Animate.CSS:https://daneden.github.io/animate.css/27、ECharts：https://www.echartsjs.com/index.html28、HighCharts：https://www.highcharts.com.cn/29、富文本编辑器wangEditor： http://www.wangeditor.com/30、富文本编辑器UEditor： https://ueditor.baidu.com/website/onlinedemo.html31、蚂蚁数据可视化：http://antv.alipay.com/zh-cn/index.html32、热力图插件：https://www.patrick-wied.at/static/heatmapjs/33、视频监控直播的插件VLC：https://www.videolan.org/34、聊天开放软件：https://www.oschina.net/p/keybase35、有道翻译API：http://fanyi.youdao.com/openapi?path=data-mode36、力扣JS题库：https://leetcode-cn.com/37、ES6入门（阮一峰大佬的）：http://es6.ruanyifeng.com/38、babel（将ES6代码转为ES5代码）：https://babeljs.io/39、处理时间与日期的JS库：http://momentjs.cn/40、Lodash：https://www.lodashjs.com/41、你可能不需要jQuery：http://youmightnotneedjquery.com/42、云小蜜智能机器人API：https://help.aliyun.com/product/59495.html?spm=a2c4g.11186623.3.1.7dad1b005dRM5F43、易万维源接口：https://www.showapi.com/api/apiList44、短信验证码接口：https://www.mysubmail.com/sms/api?tag=jq2245、榛子短信验证码接口： http://smsow.zhenzikj.com/46、草料二维码生成器：https://cli.im/ 47、RAP2假数据接口：http://rap2.taobao.org/48、可扒的真实电商数据：http://www.xiongmaoyouxuan.com/#/49、易文档接口：https://easydoc.xyz - - 感谢旅行呱大佬帮助我们丰富资源，他的CSDN主页为：https://me.csdn.net/atsoar50、免费接口：http://www.bejson.com/knownjson/webInterface/51、假数据接口（测试用）：http://jsonplaceholder.typicode.com/52、上传文件转进制的formData: https://developer.mozilla.org/zh-CN/docs/Web/API/FormData53、jQuery插件库：http://www.jq22.com/search54、轮播图插件：https://www.swiper.com.cn/55、放大镜插件：http://www.elevateweb.co.uk/image-zoom/examples56、响应式瀑布流插件：http://www.jq22.com/jquery-info2026157、小表情的emoji：https://emojipedia.org/58、Postman测试前端请求后端接口：https://www.getpostman.com/59、coding代码托管平台：https://coding.net/60、码云代码托管平台：https://gitee.com/61、github代码托管平台：https://github.com/62、SVN代码托管平台：https://svnbucket.com/?ADTAG=bdss#/63、SVN代码托管中心：http://www.svnchina.com/64、禅道：https://www.zentao.net/65、蓝湖（ps切图）：https://lanhuapp.com/66、git官网：https://git-scm.com/67、npm官网：https://www.npmjs.com/68、码神岛： https://msd.misuland.com/69、掘金网：https://juejin.im/70、思否：https://segmentfault.com/71、知乎：https://www.zhihu.com72、stack Overflow：https://stackoverflow.com/73、v2ex社区：https://www.v2ex.com/74、阿里云：https://www.aliyun.com75、腾讯云：https://cloud.tencent.com/76、GitBook：https://legacy.gitbook.com/@llh91100177、妙味课堂：https://miaov.com/78、慕课网：https://www.imooc.com/79、html中文网：https://www.html.cn/80、hCoder：http://www.hcoder.net/81、扣丁学堂：http://www.codingke.com/82、gitbook： https://legacy.gitbook.com/83、React官网：https://reactjs.org/84、Redux官网：https://react-redux.js.org/85、React Router：https://reacttraining.com/react-router/86、Vue官网：https://cn.vuejs.org/87、NodeJS官网：http://nodejs.cn/88、uni-app：https://uniapp.dcloud.io/89、微信开发者平台：https://developers.weixin.qq.com/90、钉钉开发者平台: https://ding-doc.dingtalk.com/91、百度地图开发者平台：https://passport.baidu.com92、DvaJS：https://dvajs.com/93、jQuery官网：https://jquery.com/94、jQuery API中文文档：http://jquery.cuishifeng.cn/95、ZeptoJS官网：https://zeptojs.com/96、cheerioJS安装地址：https://www.npmjs.com/package/cheerio97、RequireJS官网：https://requirejs.org/98、Sass官网（CSS预处理器，通过编程的方式来开发CSS）：https://sass-lang.com/99、Less官网（同上）：http://lesscss.org/100、Bootstrap官网：https://www.bootcss.com/101、VScode快捷键介绍：https://www.cnblogs.com/bindong/p/6045957.html102、Socket通信：https://socket.io/103、JSONPlaceholder：http://jsonplaceholder.typicode.com/104、拉勾网：https://www.lagou.com/105、Boss直聘：https://www.zhipin.com/?sid=sem_pz_bdpc_dasou_title106、猎聘网：https://www.liepin.com/107、智联招聘：http://landing.zhaopin.com/register108、一早一晚（国内远程工程师招聘）：https://yizaoyiwan.com/109、web开发互助网：http://hz.uyi2.com/110、前端面试题一到三年： https://blog.csdn.net/weixin_43606158/article/details/89811189111、前端面试题三到五年：https://blog.csdn.net/weixin_43606158/article/details/89640672112、项目中常用插件：https://blog.csdn.net/weixin_43606158/article/details/90136700113、CSDN吴小迪的博客：https://blog.csdn.net/weixin_43606158]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx学习]]></title>
    <url>%2F2019%2F08%2F10%2Fnginx%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、正向代理 内网服务器主动去请求外网服务的一种行为，明确知道要访问哪个服务器 正向：相同的或一致的方向 代理：自己做不了的事情或者自己不打算的事情，委托或依靠别人来完成 定义：就是客户端无法主动或者不打算完成主动去向服务器发起请求，而是委托了nginx代理服务器去向服务器发起请求，并且获得处理结果，返回给客户端 2、反向代理 reverse proxy 是指用代理服务器来接收客户端发来的请求，然后将请求转发给内网的上游服务器，上游服务器处理完之后，把结果通过nginx返回给客户端 对于来自外界的请求，nginx统一接收，按需转发给内网的服务器，并且把处理请求返回给外界客户端，此时代理服务器对外的表现就是一个web服务器，客户端根本不知道‘上游服务器’的存在，只知道代理服务器，不知道实际的服务器 3、透明代理 也叫简单代理，客户端向服务端发起请求，请求会先到达代理服务器，代理服务器再转交给真实的原服务器处理，也就是客户端根本不知道有代理服务器的存在 有人说透明代理和反向代理有点像，都是由代理服务器接收请求，再转发到原服务器，其实本质上是有区别的，透明代理是客户端感知不到代理服务器的存在，而反向代理是客户端感知只有一个代理服务器的存在，因此他们一个是隐藏了自己，一个是隐藏了源服务器，事实上，透明代理和正向代理才是想象的，都是由客户端主动发起请求，代理服务器去处理他们，差异点在于，正向代理是代理服务器代替客户端请求，而透明代理是客户端在发起请求时，会先经过透明代理服务器，再达到服务端，在这过程中，客户是感知不到代理服务器的存在 4、负载均衡 将服务器接收到的请求按照规则分发的过程，称为负载均衡，负载均衡是反向代理的一种表现 负载均衡有以下几种模式 1、轮询 2、ip_hash 3、url_hash 4、fair 5、处理 5、静态服务器 前后端分离中，前端项目的运行是不需要用tomcat，apache等服务器的，可以用nginx直接作为静态服务器 6、nginx的安装 学了这么多nginx的配置用法之后，我们需要对每一个知识点做一下测试，才能印象深刻，在此之前，我们需要知道nginx是怎么安装，下面以Linux环境为例，简述yum方式安装nginx的步骤： 安装依赖： //一键安装上面四个依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 安装nginx： yum install nginx 检查是否安装成功： nginx -v 启动/挺尸nginx： /etc/init.d/nginx start 2/etc/init.d/nginx stop 编辑配置文件： /etc/nginx/nginx.conf 这些步骤都完成之后，我们就可以进入nginx的配置文件nginx.conf对上面的各个知识点，进行配置和测试了。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx502]]></title>
    <url>%2F2019%2F07%2F30%2Fnginx502%2F</url>
    <content type="text"><![CDATA[nginx 报错 502 这真是一个让人很恶心的bug，从网上搜索出各种各样这种bug的解决方案，众说纷纭 https://www.jb51.net/article/141404.htm 在测试上，预生产和生产上都配置了前后端相同的代码，连nginx的配置都一样，然而在测试和预生产上没有问题，在生产上却报502错误，搞了一晚上，最后都没有解决，没有办法，回退代码第二天将生产上的配置文件的名字原来是auth-fp.conf改为 prd-auth-fp.conf竟然好了，谁会想到是nginx配置文件的名字的问题，关键是http没有问题，https却有问题，这难道就是因为https对auth这个词有什么判断，也没法解释 结论就是不要用auth等关键词做配置文件的名字]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断页面是首次被加载还是刷新]]></title>
    <url>%2F2019%2F05%2F28%2Fjs%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E6%98%AF%E9%A6%96%E6%AC%A1%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%98%E6%98%AF%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1、利用weindow.name属性在页面刷新时不会重置判断（在该属性空置的情况下可使用） if(window.name == ‘’){ console.log(‘首次被加载’) window.name = ‘isReload’ }else if(window.name == ‘isReload’){ console.log(‘页面被刷新’) } 2、使用sessionStorage或cookie来判断 与window.name实现方法类似，在首次加载时设置一个固定值，之后判断即可 if(sessionStorage.getItem(‘isReload’)){ console.log(‘页面被刷新’) }else{ console.log(‘首次被加载’) sessionStorage.setItem(‘isReload’,true) }3、可以使用window.chrome对象 if (window.performance.navigation.type == 1) { console.log(“页面被刷新”) }else{ console.log(“首次被加载”) }]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview 分页全选反选的实现思路]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%88%86%E9%A1%B5%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、首先定义一个type来确定是初始化表格还是搜索表格 1、在初始化的时候定义一个数组来接受一个初始化选中的id this.initialchoice = [] 2、在表格里面修改数据的时候，分四种：第一、是选中，第二、是反选，不选中，第三、全选中当前表格，第四、反选当前表格 第一种：直接在数组中push进去， this.initialchoice.push(id) @on-select 第二种：反选，查找当前id在初始化数组中的位置，直接删除 @on-select-cancel 第三种：全选当前表格：将当前表格的id，push到初始化数组当中，最后去重 @on-select-all 第四种：反选当前表格：将当前表格的id和初始化数组进行循环对比，如果值相同直接splice掉就可以 @on-select-all-cancel]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git排除某个文件提交]]></title>
    <url>%2F2019%2F05%2F13%2Fgit%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[1、cat .git/config2、git config core.excludesfile .gitignore3、&gt;.gitignore只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。解决方法是先把本地缓存删除，然后再提交。 git rm -r –cached . git add .4、如果缓存中有重要的数据更改，那么你需要单独删除不要的缓存： git rm –cached logs/xx.log]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 实现换主题/皮肤功能]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%AE%9E%E7%8E%B0%E6%8D%A2%E4%B8%BB%E9%A2%98-%E7%9A%AE%E8%82%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、实现思路 我们用vue一般都是写单页面程序，因此在实际发布的时候只有一个html以及一堆静态文件（js、css、img之类）。而在html中引用了这些js和css。我们要换皮肤的话其实就是动态的去切换css，所以在这里实现换皮肤其实也就是动态的更改html中引用css的路径，使得当用户选择了不同的皮肤，页面引用的css不同从而呈现的样式也不一样。 2、优化策略 其实在实际场景中，需要通过切换皮肤来改变css的元素占所有css的比重并不会很多，因此我们需要把需要通过切换改变的css单独提取出来，在动态改变css路径时只需要去改变这个控制皮肤的css就可以了。 把皮肤相关的css压缩。 3、实现代码分析 如下是我们的html代码，注意其中的，其他的都是正常引用。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;title&gt;iView admin&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;&gt; &lt;!-- 注意这是我们换皮肤需要的css --&gt; &lt;link rel=&quot;stylesheet&quot; name=&quot;theme&quot; href=&quot;&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来就是具体实现换皮肤功能了，换皮肤一般都是点击一个按钮弹出一些皮肤的选项，选中选项后皮肤生效。 &lt;template&gt; &lt;div class=&quot;app-settings d-none d-md-block&quot;&gt; &lt;button class=&quot;btn&quot; @click=&quot;toggle&quot;&gt;&lt;i class=&quot;fa fa-gear fa-spin&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;div class=&quot;py-2 bb-l&quot;&gt;主题设置&lt;/div&gt; &lt;div class=&quot;row no-gutters px-2 mt-2 mb-2 theme-switcher&quot;&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themeblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;blue&apos;}&quot; title=&quot;Blue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1 mb-1&quot;&gt; &lt;label class=&quot;bg-themelightblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;lightblue&apos;}&quot; title=&quot;Lightblue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themedarkblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;darkblue&apos;}&quot; title=&quot;Darkblue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themelightpurple&quot; :class=&quot;{&apos;active&apos;: theme == &apos;lightpurple&apos;}&quot; title=&quot;LightPurple&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;appSettings&apos;, data: () =&gt; ({ layout: [&apos;header-fixed&apos;], theme: localStorage.theme || &apos;blue&apos; }), created () { // 非默认主题, 则进行切换 if (this.theme) { document.getElementById(&apos;app-theme&apos;).setAttribute(&apos;href&apos;, `/static/css/newtheme-${this.theme}.css`) } else { document.getElementById(&apos;app-theme&apos;).removeAttribute(&apos;href&apos;) } }, methods: { // 切换主题颜色 active (e, theme) { // 获取选中主题, 优先使用参数传递的主题 if(e.target.title != &apos;&apos;){ if(e.target.title.toLowerCase() != this.theme.toLowerCase()){ theme = theme || e.target.title.toLowerCase() // 更改样式链接 document.getElementById(&apos;app-theme&apos;).setAttribute(&apos;href&apos;, `/static/css/newtheme-${theme}.css`) // 保存 localStorage.setItem(&apos;theme&apos;, theme) this.theme = theme; // var ofrm1 = document.getElementById(&quot;iframeid&quot;).contentWindow.document; this.changeOriginTheme() } } }, changeOriginTheme(){ var that = this; let mapFrame = $(&quot;#iframeid&quot;); if(mapFrame.length &gt; 0){ let iframeWin = mapFrame[0].contentWindow; iframeWin.postMessage({ &apos;themecolor&apos;: that.theme },&apos;*&apos;) } }, toggle () { this.$el.classList.toggle(&apos;show&apos;) } } } &lt;/script&gt;]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域iframe通信]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%B7%A8%E5%9F%9Fiframe%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[提要： 应项目的需求，需要在主域中嵌入不同域的iframe地址，但这个时候需要向嵌入的子域中传输一些数据 实现方式： 直接上代码如下：]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户和用户组]]></title>
    <url>%2F2019%2F03%2F19%2F%E2%80%98%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%2F</url>
    <content type="text"><![CDATA[groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c ‘Name Surname’ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于‘admin’用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户(‘-r’排除主目录)usermod -c ‘user FTP’ -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令(只允许root执行)change -E 2015-12-31 user1 设置用户口令的失效期限pwck 检查’etc/passwd’的文件格式和语法修正以及存在的用户grpck 检查’etc/passwd’的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 pwd]]></title>
    <url>%2F2019%2F03%2F18%2Fpwd%2F</url>
    <content type="text"><![CDATA[一、Linux pwd命令语法 pwd [OPTION]… 参数说明: -L, –logical #use PWD from environment, even if it contains symlinks -P, –physical #avoid all symlinks –help #display this help and exit –version #output version information and exit -L 目录连接链接时，输出连接路径 -P 输出物理路径 二、Linux pwd命令实例 查看当前所在目录： 查看链接路径 写到环境变量中 export PS1=’[\u@$PWD]\$’ 这样在命令提示符前方会显示出当前的目录 [root@/root/linuxdaxue.com/testDir]# ok，有关Linux pwd命令的相关内容就先给大家介绍到这里。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 mv]]></title>
    <url>%2F2019%2F03%2F15%2Fmv%2F</url>
    <content type="text"><![CDATA[1.作用mv命令用来为文件或目录改名，或者将文件由一个目录移入另一个目录中，它的使用权限是所有用户。该命令如同DOS命令中的ren和move的组合。2.格式mv[options] 源文件或目录 目标文件或目录3.[options]主要参数－i：交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，这样可以避免误覆盖文件。－f：禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。4.应用实例（1）将/usr/cbu中的所有文件移到当前目录（用“.”表示）中：$ mv /usr/cbu/ * .（2）将文件cjh.txt重命名为wjz.txt：$ mv cjh.txt wjz.txt]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 tar]]></title>
    <url>%2F2019%2F03%2F14%2Ftar%2F</url>
    <content type="text"><![CDATA[tar -c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -xf all.tar这条命令是解出all.tar包中所有文件，-x是解开的意思 压缩tar –cvf jpg.tar .jpg 将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar .jpg rar格式的压缩，需要先下载rar for linuxzip jpg.zip .jpg zip格式的压缩，需要先下载zip for linux解压tar –xvf file.tar 解压 tar包tar -xzvf file.tar.gz 解压tar.gztar -xjvf file.tar.bz2 解压 tar.bz2tar –xZvf file.tar.Z 解压tar.Zunrar e file.rar 解压rarunzip file.zip 解压zip 总结.tar 用 tar –xvf 解压 .gz 用 gzip -d或者gunzip 解压.tar.gz和.tgz 用 tar –xzf 解压.bz2 用 bzip2 -d或者用bunzip2 解压 .tar.bz2用tar –xjf 解压.Z 用 uncompress 解压 .tar.Z 用tar –xZf 解压.rar 用 unrar e解压 .zip 用 unzip 解压 linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。 1．命令格式： tar[必要参数][选择参数][文件] 2．命令功能： 用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 3．命令参数： 必要参数有如下： -A 新增压缩文件到已存在的压缩 -B 设置区块大小 -c 建立新的压缩文件 -d 记录文件的差别 -r 添加文件到已经压缩的文件 -u 添加改变了和现有的文件到已经存在的压缩文件 -x 从压缩的文件中提取文件 -t 显示压缩文件的内容 -z 支持gzip解压文件 -j 支持bzip2解压文件 -Z 支持compress解压文件 -v 显示操作过程 -l 文件系统边界设置 -k 保留原有文件不覆盖 -m 保留文件不被覆盖 -W 确认压缩文件的正确性 可选参数如下： -b 设置区块数目 -C 切换到指定目录 -f 指定压缩文件 –help 显示帮助信息 –version 显示版本信息 4．常见解压/压缩命令 tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName 5．使用实例 实例1：将文件全部打包成tar包 命令： tar -cvf log.tar log2012.log tar -zcvf log.tar.gz log2012.log tar -jcvf log.tar.bz2 log2012.log]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 cp]]></title>
    <url>%2F2019%2F03%2F14%2Fcp%2F</url>
    <content type="text"><![CDATA[一、复制一个源文件到目标文件（夹）。 命令格式为：cp 源文件 目标文件（夹） 这个是使用频率最多的命令，负责把一个源文件复制到目标文件（夹）下。如下图所示，复制到文件夹下，则文件名保持不变，复制到文件中，则文件名变更。如果目标文件已经存在或目标文件夹中含有同名文件，则复制之后目标文件或目标文件夹中的同名文件会被覆盖。 二、同时复制多个文件到目标文件（夹）下。 命令格式为：cp 源文件1 源文件2 目标文件夹 或 cp 文件* 目标文件夹 这个命令使用频率也很高。第一种命令格式可以把列出来的多个文件一次性复制到目标文件夹下，每个文件直接用空格分隔；第二种命令格式使用了通配符*，如下图所示，可以将所有以“.txt”结尾的文件都复制到文件夹testDir下。 三、复制源文件夹到目标文件夹下。 命令格式为：cp -r 源文件夹 目标文件夹 这个也是使用频率很高的命令，只需要记住复制文件夹一定要加“-r”参数，否则会出现“cp: omitting directory”错误。 四、只有源文件较目标文件新时复制。 命令格式为：cp -u 源文件 目标文件 这个命令很实用，尤其是在更新文件时。如下图所示，只有源文件比目标文件新时，才会将源文件复制给目标文件，否则，及时执行了命令，也不会执行复制。 五、创建文件的软链接。 命令格式为：cp -s 源文件 目标文件 也可以用ln命令实现同样的功能。当一个文件路径太深（如下述的a/b/c/d/e/orginalFile.txt），访问起来十分不方便时，就会创建这个文件的软链接，使之访问起来更方便些。软链接就相当于windows上的快捷方式。 六、创建文件的硬链接。 命令格式为：cp -l 源文件 目标文件 也可以用ln命令实现同样的功能。有时候，为了某种原因，需要创建一个硬链接，如下图所示。 这里简单介绍下硬链接和软链接的区别。如下图所示，软连接文件（softLink.txt）和被链接文件（orginalFile.txt）所拥有的inode不相同（133827和139819），硬链接文件（hardLink.txt）和被链接的文件（orginalFile22.txt）拥有相同的inode（156981）。当被链接的文件删除时，软链接文件也无法访问了，而硬链接文件仍能正常访问。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装好自己的博客，想要更改主题]]></title>
    <url>%2F2019%2F03%2F13%2Fblogtheme%2F</url>
    <content type="text"><![CDATA[1、从git上下载yelee主题放到themes文件夹下 git clone git@github.com:MOxFIVE/hexo-theme-yelee.git themes/yelee 2、更改blog文件夹下的_config.yml文件 将theme改成yelee 3、然后执行 hexo s 可以到网站上查看是否完成 ps：网站再次进行部署时，还需要清理public文件夹内容，重新生成部署，用以下命令。 hexo clean #尤其在更换主题后使用 hexo g hexo d]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github一步步搭建属于自己的博客（基础）]]></title>
    <url>%2F2019%2F03%2F12%2Fmyfirstblog%2F</url>
    <content type="text"><![CDATA[1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来是进阶的操作 如何上传文章到git：hexo clean (清空资源文件，可选操作)hexo g(重新生成资源文件)hexo server（本地发布文章）本地发布后查看效果：http://localhost:4000/hexo deploy(发布文章到github.io)输入github账号，密码查看远程效果]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
