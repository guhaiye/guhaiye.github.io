<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端开发应知网站]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BA%94%E7%9F%A5%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[作为一名前端开发者（所有程序员）最起码遇到bug就算不会解决也应该会搜解决问题的答案。 1、一般笔者会先在百度搜（关键词一定要输入正确）2、如果没搜到会再去bing里面看看3、还没有的话就去github的Issues里面再看看4、如果还不行就只能自己去看官方文档然后自己研究了。 下面一些链接是一些经常可以用到的网站，以此分享给大家1、MDN开发者文档：https://developer.mozilla.org/zh-CN/2、菜鸟教程：https://www.runoob.com/3、W3CSchool：http://www.w3school.com.cn/4、JavaScript教程网：https://zh.javascript.info/5、一行代码搞定bug监控：https://www.fundebug.com/?tdsourcetag=s_pcqq_aiomsg6、web开发人员必备工具包（实现快速敲代码）:https://docs.emmet.io/7、让代码提交的时候先执行一次代码，如果有报错不让提交：www.npmjs.com/package/eslint-config-airbnb8、阿里巴巴图标库：https://www.iconfont.cn/9、UI颜色布料：https://www.materialui.co/colors10、UI必备颜色表（色块+色码）:https://blog.csdn.net/weixin_43606158/article/details/9756917611、logo在线制作，有很多：http://www.logofree.cn/12、在线开发工具：https://tool.lu/c/developer13、项目部署流程：https://cloud.tencent.com/developer/information/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A412、谷歌浏览器插件下载地址： http://chromecj.com/13、网站SEO： http://www.jj3721.com/14、前端开发必备JS功能函数总结（上）：https://blog.csdn.net/weixin_43606158/article/details/9459047415、前端开发必备JS功能函数总结（下）：https://blog.csdn.net/weixin_43606158/article/details/9466040216、渐进式web应用程序核对表：https://developers.google.cn/web/progressive-web-apps/checklist17、在线存放图片的地址：https://sm.ms/18、代码变漂亮图片：https://carbon.now.sh19、MintUI：https://mint-ui.github.io/#!/zh-cn20、ElementUI：https://element.eleme.cn/#/zh-CN21、iViewUI：https://www.iviewui.com/22、Layui：https://www.layui.com/23、cubeUI：https://didi.github.io/cube-ui/#/zh-CN24、Antd：https://ant.design/index-cn25、MUI：http://dev.dcloud.net.cn/mui/26、Animate.CSS:https://daneden.github.io/animate.css/27、ECharts：https://www.echartsjs.com/index.html28、HighCharts：https://www.highcharts.com.cn/29、富文本编辑器wangEditor： http://www.wangeditor.com/30、富文本编辑器UEditor： https://ueditor.baidu.com/website/onlinedemo.html31、蚂蚁数据可视化：http://antv.alipay.com/zh-cn/index.html32、热力图插件：https://www.patrick-wied.at/static/heatmapjs/33、视频监控直播的插件VLC：https://www.videolan.org/34、聊天开放软件：https://www.oschina.net/p/keybase35、有道翻译API：http://fanyi.youdao.com/openapi?path=data-mode36、力扣JS题库：https://leetcode-cn.com/37、ES6入门（阮一峰大佬的）：http://es6.ruanyifeng.com/38、babel（将ES6代码转为ES5代码）：https://babeljs.io/39、处理时间与日期的JS库：http://momentjs.cn/40、Lodash：https://www.lodashjs.com/41、你可能不需要jQuery：http://youmightnotneedjquery.com/42、云小蜜智能机器人API：https://help.aliyun.com/product/59495.html?spm=a2c4g.11186623.3.1.7dad1b005dRM5F43、易万维源接口：https://www.showapi.com/api/apiList44、短信验证码接口：https://www.mysubmail.com/sms/api?tag=jq2245、榛子短信验证码接口： http://smsow.zhenzikj.com/46、草料二维码生成器：https://cli.im/ 47、RAP2假数据接口：http://rap2.taobao.org/48、可扒的真实电商数据：http://www.xiongmaoyouxuan.com/#/49、易文档接口：https://easydoc.xyz - - 感谢旅行呱大佬帮助我们丰富资源，他的CSDN主页为：https://me.csdn.net/atsoar50、免费接口：http://www.bejson.com/knownjson/webInterface/51、假数据接口（测试用）：http://jsonplaceholder.typicode.com/52、上传文件转进制的formData: https://developer.mozilla.org/zh-CN/docs/Web/API/FormData53、jQuery插件库：http://www.jq22.com/search54、轮播图插件：https://www.swiper.com.cn/55、放大镜插件：http://www.elevateweb.co.uk/image-zoom/examples56、响应式瀑布流插件：http://www.jq22.com/jquery-info2026157、小表情的emoji：https://emojipedia.org/58、Postman测试前端请求后端接口：https://www.getpostman.com/59、coding代码托管平台：https://coding.net/60、码云代码托管平台：https://gitee.com/61、github代码托管平台：https://github.com/62、SVN代码托管平台：https://svnbucket.com/?ADTAG=bdss#/63、SVN代码托管中心：http://www.svnchina.com/64、禅道：https://www.zentao.net/65、蓝湖（ps切图）：https://lanhuapp.com/66、git官网：https://git-scm.com/67、npm官网：https://www.npmjs.com/68、码神岛： https://msd.misuland.com/69、掘金网：https://juejin.im/70、思否：https://segmentfault.com/71、知乎：https://www.zhihu.com72、stack Overflow：https://stackoverflow.com/73、v2ex社区：https://www.v2ex.com/74、阿里云：https://www.aliyun.com75、腾讯云：https://cloud.tencent.com/76、GitBook：https://legacy.gitbook.com/@llh91100177、妙味课堂：https://miaov.com/78、慕课网：https://www.imooc.com/79、html中文网：https://www.html.cn/80、hCoder：http://www.hcoder.net/81、扣丁学堂：http://www.codingke.com/82、gitbook： https://legacy.gitbook.com/83、React官网：https://reactjs.org/84、Redux官网：https://react-redux.js.org/85、React Router：https://reacttraining.com/react-router/86、Vue官网：https://cn.vuejs.org/87、NodeJS官网：http://nodejs.cn/88、uni-app：https://uniapp.dcloud.io/89、微信开发者平台：https://developers.weixin.qq.com/90、钉钉开发者平台: https://ding-doc.dingtalk.com/91、百度地图开发者平台：https://passport.baidu.com92、DvaJS：https://dvajs.com/93、jQuery官网：https://jquery.com/94、jQuery API中文文档：http://jquery.cuishifeng.cn/95、ZeptoJS官网：https://zeptojs.com/96、cheerioJS安装地址：https://www.npmjs.com/package/cheerio97、RequireJS官网：https://requirejs.org/98、Sass官网（CSS预处理器，通过编程的方式来开发CSS）：https://sass-lang.com/99、Less官网（同上）：http://lesscss.org/100、Bootstrap官网：https://www.bootcss.com/101、VScode快捷键介绍：https://www.cnblogs.com/bindong/p/6045957.html102、Socket通信：https://socket.io/103、JSONPlaceholder：http://jsonplaceholder.typicode.com/104、拉勾网：https://www.lagou.com/105、Boss直聘：https://www.zhipin.com/?sid=sem_pz_bdpc_dasou_title106、猎聘网：https://www.liepin.com/107、智联招聘：http://landing.zhaopin.com/register108、一早一晚（国内远程工程师招聘）：https://yizaoyiwan.com/109、web开发互助网：http://hz.uyi2.com/110、前端面试题一到三年： https://blog.csdn.net/weixin_43606158/article/details/89811189111、前端面试题三到五年：https://blog.csdn.net/weixin_43606158/article/details/89640672112、项目中常用插件：https://blog.csdn.net/weixin_43606158/article/details/90136700113、CSDN吴小迪的博客：https://blog.csdn.net/weixin_43606158]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx学习]]></title>
    <url>%2F2019%2F08%2F10%2Fnginx%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、正向代理 内网服务器主动去请求外网服务的一种行为，明确知道要访问哪个服务器 正向：相同的或一致的方向 代理：自己做不了的事情或者自己不打算的事情，委托或依靠别人来完成 定义：就是客户端无法主动或者不打算完成主动去向服务器发起请求，而是委托了nginx代理服务器去向服务器发起请求，并且获得处理结果，返回给客户端 2、反向代理 reverse proxy 是指用代理服务器来接收客户端发来的请求，然后将请求转发给内网的上游服务器，上游服务器处理完之后，把结果通过nginx返回给客户端 对于来自外界的请求，nginx统一接收，按需转发给内网的服务器，并且把处理请求返回给外界客户端，此时代理服务器对外的表现就是一个web服务器，客户端根本不知道‘上游服务器’的存在，只知道代理服务器，不知道实际的服务器 3、透明代理 也叫简单代理，客户端向服务端发起请求，请求会先到达代理服务器，代理服务器再转交给真实的原服务器处理，也就是客户端根本不知道有代理服务器的存在 有人说透明代理和反向代理有点像，都是由代理服务器接收请求，再转发到原服务器，其实本质上是有区别的，透明代理是客户端感知不到代理服务器的存在，而反向代理是客户端感知只有一个代理服务器的存在，因此他们一个是隐藏了自己，一个是隐藏了源服务器，事实上，透明代理和正向代理才是想象的，都是由客户端主动发起请求，代理服务器去处理他们，差异点在于，正向代理是代理服务器代替客户端请求，而透明代理是客户端在发起请求时，会先经过透明代理服务器，再达到服务端，在这过程中，客户是感知不到代理服务器的存在 4、负载均衡 将服务器接收到的请求按照规则分发的过程，称为负载均衡，负载均衡是反向代理的一种表现 负载均衡有以下几种模式 1、轮询 2、ip_hash 3、url_hash 4、fair 5、处理 5、静态服务器 前后端分离中，前端项目的运行是不需要用tomcat，apache等服务器的，可以用nginx直接作为静态服务器 6、nginx的安装 学了这么多nginx的配置用法之后，我们需要对每一个知识点做一下测试，才能印象深刻，在此之前，我们需要知道nginx是怎么安装，下面以Linux环境为例，简述yum方式安装nginx的步骤： 安装依赖： //一键安装上面四个依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 安装nginx： yum install nginx 检查是否安装成功： nginx -v 启动/挺尸nginx： /etc/init.d/nginx start 2/etc/init.d/nginx stop 编辑配置文件： /etc/nginx/nginx.conf 这些步骤都完成之后，我们就可以进入nginx的配置文件nginx.conf对上面的各个知识点，进行配置和测试了。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx502]]></title>
    <url>%2F2019%2F07%2F30%2Fnginx502%2F</url>
    <content type="text"><![CDATA[nginx 报错 502 这真是一个让人很恶心的bug，从网上搜索出各种各样这种bug的解决方案，众说纷纭 https://www.jb51.net/article/141404.htm 在测试上，预生产和生产上都配置了前后端相同的代码，连nginx的配置都一样，然而在测试和预生产上没有问题，在生产上却报502错误，搞了一晚上，最后都没有解决，没有办法，回退代码第二天将生产上的配置文件的名字原来是auth-fp.conf改为 prd-auth-fp.conf竟然好了，谁会想到是nginx配置文件的名字的问题，关键是http没有问题，https却有问题，这难道就是因为https对auth这个词有什么判断，也没法解释 结论就是不要用auth等关键词做配置文件的名字]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断页面是首次被加载还是刷新]]></title>
    <url>%2F2019%2F05%2F28%2Fjs%E5%88%A4%E6%96%AD%E9%A1%B5%E9%9D%A2%E6%98%AF%E9%A6%96%E6%AC%A1%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%98%E6%98%AF%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1、利用weindow.name属性在页面刷新时不会重置判断（在该属性空置的情况下可使用） if(window.name == ‘’){ console.log(‘首次被加载’) window.name = ‘isReload’ }else if(window.name == ‘isReload’){ console.log(‘页面被刷新’) } 2、使用sessionStorage或cookie来判断 与window.name实现方法类似，在首次加载时设置一个固定值，之后判断即可 if(sessionStorage.getItem(‘isReload’)){ console.log(‘页面被刷新’) }else{ console.log(‘首次被加载’) sessionStorage.setItem(‘isReload’,true) }3、可以使用window.chrome对象 if (window.performance.navigation.type == 1) { console.log(“页面被刷新”) }else{ console.log(“首次被加载”) }]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview 分页全选反选的实现思路]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%88%86%E9%A1%B5%E5%85%A8%E9%80%89%E5%8F%8D%E9%80%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、首先定义一个type来确定是初始化表格还是搜索表格 1、在初始化的时候定义一个数组来接受一个初始化选中的id this.initialchoice = [] 2、在表格里面修改数据的时候，分四种：第一、是选中，第二、是反选，不选中，第三、全选中当前表格，第四、反选当前表格 第一种：直接在数组中push进去， this.initialchoice.push(id) @on-select 第二种：反选，查找当前id在初始化数组中的位置，直接删除 @on-select-cancel 第三种：全选当前表格：将当前表格的id，push到初始化数组当中，最后去重 @on-select-all 第四种：反选当前表格：将当前表格的id和初始化数组进行循环对比，如果值相同直接splice掉就可以 @on-select-all-cancel]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git排除某个文件提交]]></title>
    <url>%2F2019%2F05%2F13%2Fgit%E6%8E%92%E9%99%A4%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[1、cat .git/config2、git config core.excludesfile .gitignore3、&gt;.gitignore只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。解决方法是先把本地缓存删除，然后再提交。 git rm -r –cached . git add .4、如果缓存中有重要的数据更改，那么你需要单独删除不要的缓存： git rm –cached logs/xx.log]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 实现换主题/皮肤功能]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%AE%9E%E7%8E%B0%E6%8D%A2%E4%B8%BB%E9%A2%98-%E7%9A%AE%E8%82%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[1、实现思路 我们用vue一般都是写单页面程序，因此在实际发布的时候只有一个html以及一堆静态文件（js、css、img之类）。而在html中引用了这些js和css。我们要换皮肤的话其实就是动态的去切换css，所以在这里实现换皮肤其实也就是动态的更改html中引用css的路径，使得当用户选择了不同的皮肤，页面引用的css不同从而呈现的样式也不一样。 2、优化策略 其实在实际场景中，需要通过切换皮肤来改变css的元素占所有css的比重并不会很多，因此我们需要把需要通过切换改变的css单独提取出来，在动态改变css路径时只需要去改变这个控制皮肤的css就可以了。 把皮肤相关的css压缩。 3、实现代码分析 如下是我们的html代码，注意其中的，其他的都是正常引用。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;title&gt;iView admin&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;&gt; &lt;!-- 注意这是我们换皮肤需要的css --&gt; &lt;link rel=&quot;stylesheet&quot; name=&quot;theme&quot; href=&quot;&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 接下来就是具体实现换皮肤功能了，换皮肤一般都是点击一个按钮弹出一些皮肤的选项，选中选项后皮肤生效。 &lt;template&gt; &lt;div class=&quot;app-settings d-none d-md-block&quot;&gt; &lt;button class=&quot;btn&quot; @click=&quot;toggle&quot;&gt;&lt;i class=&quot;fa fa-gear fa-spin&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;div class=&quot;py-2 bb-l&quot;&gt;主题设置&lt;/div&gt; &lt;div class=&quot;row no-gutters px-2 mt-2 mb-2 theme-switcher&quot;&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themeblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;blue&apos;}&quot; title=&quot;Blue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1 mb-1&quot;&gt; &lt;label class=&quot;bg-themelightblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;lightblue&apos;}&quot; title=&quot;Lightblue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themedarkblue&quot; :class=&quot;{&apos;active&apos;: theme == &apos;darkblue&apos;}&quot; title=&quot;Darkblue&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col-6 px-1&quot;&gt; &lt;label class=&quot;bg-themelightpurple&quot; :class=&quot;{&apos;active&apos;: theme == &apos;lightpurple&apos;}&quot; title=&quot;LightPurple&quot; @click=&quot;active&quot;&gt;&lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;appSettings&apos;, data: () =&gt; ({ layout: [&apos;header-fixed&apos;], theme: localStorage.theme || &apos;blue&apos; }), created () { // 非默认主题, 则进行切换 if (this.theme) { document.getElementById(&apos;app-theme&apos;).setAttribute(&apos;href&apos;, `/static/css/newtheme-${this.theme}.css`) } else { document.getElementById(&apos;app-theme&apos;).removeAttribute(&apos;href&apos;) } }, methods: { // 切换主题颜色 active (e, theme) { // 获取选中主题, 优先使用参数传递的主题 if(e.target.title != &apos;&apos;){ if(e.target.title.toLowerCase() != this.theme.toLowerCase()){ theme = theme || e.target.title.toLowerCase() // 更改样式链接 document.getElementById(&apos;app-theme&apos;).setAttribute(&apos;href&apos;, `/static/css/newtheme-${theme}.css`) // 保存 localStorage.setItem(&apos;theme&apos;, theme) this.theme = theme; // var ofrm1 = document.getElementById(&quot;iframeid&quot;).contentWindow.document; this.changeOriginTheme() } } }, changeOriginTheme(){ var that = this; let mapFrame = $(&quot;#iframeid&quot;); if(mapFrame.length &gt; 0){ let iframeWin = mapFrame[0].contentWindow; iframeWin.postMessage({ &apos;themecolor&apos;: that.theme },&apos;*&apos;) } }, toggle () { this.$el.classList.toggle(&apos;show&apos;) } } } &lt;/script&gt;]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域iframe通信]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%B7%A8%E5%9F%9Fiframe%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[提要： 应项目的需求，需要在主域中嵌入不同域的iframe地址，但这个时候需要向嵌入的子域中传输一些数据 实现方式： 直接上代码如下：]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户和用户组]]></title>
    <url>%2F2019%2F03%2F19%2F%E2%80%98%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%2F</url>
    <content type="text"><![CDATA[groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c ‘Name Surname’ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于‘admin’用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户(‘-r’排除主目录)usermod -c ‘user FTP’ -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令(只允许root执行)change -E 2015-12-31 user1 设置用户口令的失效期限pwck 检查’etc/passwd’的文件格式和语法修正以及存在的用户grpck 检查’etc/passwd’的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 pwd]]></title>
    <url>%2F2019%2F03%2F18%2Fpwd%2F</url>
    <content type="text"><![CDATA[一、Linux pwd命令语法 pwd [OPTION]… 参数说明: -L, –logical #use PWD from environment, even if it contains symlinks -P, –physical #avoid all symlinks –help #display this help and exit –version #output version information and exit -L 目录连接链接时，输出连接路径 -P 输出物理路径 二、Linux pwd命令实例 查看当前所在目录： 查看链接路径 写到环境变量中 export PS1=’[\u@$PWD]\$’ 这样在命令提示符前方会显示出当前的目录 [root@/root/linuxdaxue.com/testDir]# ok，有关Linux pwd命令的相关内容就先给大家介绍到这里。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 mv]]></title>
    <url>%2F2019%2F03%2F15%2Fmv%2F</url>
    <content type="text"><![CDATA[1.作用mv命令用来为文件或目录改名，或者将文件由一个目录移入另一个目录中，它的使用权限是所有用户。该命令如同DOS命令中的ren和move的组合。2.格式mv[options] 源文件或目录 目标文件或目录3.[options]主要参数－i：交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，这样可以避免误覆盖文件。－f：禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。4.应用实例（1）将/usr/cbu中的所有文件移到当前目录（用“.”表示）中：$ mv /usr/cbu/ * .（2）将文件cjh.txt重命名为wjz.txt：$ mv cjh.txt wjz.txt]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 tar]]></title>
    <url>%2F2019%2F03%2F14%2Ftar%2F</url>
    <content type="text"><![CDATA[tar -c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -xf all.tar这条命令是解出all.tar包中所有文件，-x是解开的意思 压缩tar –cvf jpg.tar .jpg 将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z .jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar .jpg rar格式的压缩，需要先下载rar for linuxzip jpg.zip .jpg zip格式的压缩，需要先下载zip for linux解压tar –xvf file.tar 解压 tar包tar -xzvf file.tar.gz 解压tar.gztar -xjvf file.tar.bz2 解压 tar.bz2tar –xZvf file.tar.Z 解压tar.Zunrar e file.rar 解压rarunzip file.zip 解压zip 总结.tar 用 tar –xvf 解压 .gz 用 gzip -d或者gunzip 解压.tar.gz和.tgz 用 tar –xzf 解压.bz2 用 bzip2 -d或者用bunzip2 解压 .tar.bz2用tar –xjf 解压.Z 用 uncompress 解压 .tar.Z 用tar –xZf 解压.rar 用 unrar e解压 .zip 用 unzip 解压 linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。 1．命令格式： tar[必要参数][选择参数][文件] 2．命令功能： 用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的 3．命令参数： 必要参数有如下： -A 新增压缩文件到已存在的压缩 -B 设置区块大小 -c 建立新的压缩文件 -d 记录文件的差别 -r 添加文件到已经压缩的文件 -u 添加改变了和现有的文件到已经存在的压缩文件 -x 从压缩的文件中提取文件 -t 显示压缩文件的内容 -z 支持gzip解压文件 -j 支持bzip2解压文件 -Z 支持compress解压文件 -v 显示操作过程 -l 文件系统边界设置 -k 保留原有文件不覆盖 -m 保留文件不被覆盖 -W 确认压缩文件的正确性 可选参数如下： -b 设置区块数目 -C 切换到指定目录 -f 指定压缩文件 –help 显示帮助信息 –version 显示版本信息 4．常见解压/压缩命令 tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） .gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName .bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName .tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName .bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知 .Z解压：uncompress FileName.Z压缩：compress FileName.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName .rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName 5．使用实例 实例1：将文件全部打包成tar包 命令： tar -cvf log.tar log2012.log tar -zcvf log.tar.gz log2012.log tar -jcvf log.tar.bz2 log2012.log]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个linux命令之 cp]]></title>
    <url>%2F2019%2F03%2F14%2Fcp%2F</url>
    <content type="text"><![CDATA[一、复制一个源文件到目标文件（夹）。 命令格式为：cp 源文件 目标文件（夹） 这个是使用频率最多的命令，负责把一个源文件复制到目标文件（夹）下。如下图所示，复制到文件夹下，则文件名保持不变，复制到文件中，则文件名变更。如果目标文件已经存在或目标文件夹中含有同名文件，则复制之后目标文件或目标文件夹中的同名文件会被覆盖。 二、同时复制多个文件到目标文件（夹）下。 命令格式为：cp 源文件1 源文件2 目标文件夹 或 cp 文件* 目标文件夹 这个命令使用频率也很高。第一种命令格式可以把列出来的多个文件一次性复制到目标文件夹下，每个文件直接用空格分隔；第二种命令格式使用了通配符*，如下图所示，可以将所有以“.txt”结尾的文件都复制到文件夹testDir下。 三、复制源文件夹到目标文件夹下。 命令格式为：cp -r 源文件夹 目标文件夹 这个也是使用频率很高的命令，只需要记住复制文件夹一定要加“-r”参数，否则会出现“cp: omitting directory”错误。 四、只有源文件较目标文件新时复制。 命令格式为：cp -u 源文件 目标文件 这个命令很实用，尤其是在更新文件时。如下图所示，只有源文件比目标文件新时，才会将源文件复制给目标文件，否则，及时执行了命令，也不会执行复制。 五、创建文件的软链接。 命令格式为：cp -s 源文件 目标文件 也可以用ln命令实现同样的功能。当一个文件路径太深（如下述的a/b/c/d/e/orginalFile.txt），访问起来十分不方便时，就会创建这个文件的软链接，使之访问起来更方便些。软链接就相当于windows上的快捷方式。 六、创建文件的硬链接。 命令格式为：cp -l 源文件 目标文件 也可以用ln命令实现同样的功能。有时候，为了某种原因，需要创建一个硬链接，如下图所示。 这里简单介绍下硬链接和软链接的区别。如下图所示，软连接文件（softLink.txt）和被链接文件（orginalFile.txt）所拥有的inode不相同（133827和139819），硬链接文件（hardLink.txt）和被链接的文件（orginalFile22.txt）拥有相同的inode（156981）。当被链接的文件删除时，软链接文件也无法访问了，而硬链接文件仍能正常访问。]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装好自己的博客，想要更改主题]]></title>
    <url>%2F2019%2F03%2F13%2Fblogtheme%2F</url>
    <content type="text"><![CDATA[1、从git上下载yelee主题放到themes文件夹下 git clone git@github.com:MOxFIVE/hexo-theme-yelee.git themes/yelee 2、更改blog文件夹下的_config.yml文件 将theme改成yelee 3、然后执行 hexo s 可以到网站上查看是否完成 ps：网站再次进行部署时，还需要清理public文件夹内容，重新生成部署，用以下命令。 hexo clean #尤其在更换主题后使用 hexo g hexo d]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github一步步搭建属于自己的博客（基础）]]></title>
    <url>%2F2019%2F03%2F12%2Fmyfirstblog%2F</url>
    <content type="text"><![CDATA[1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。接下来是进阶的操作 如何上传文章到git：hexo clean (清空资源文件，可选操作)hexo g(重新生成资源文件)hexo server（本地发布文章）本地发布后查看效果：http://localhost:4000/hexo deploy(发布文章到github.io)输入github账号，密码查看远程效果]]></content>
      <tags>
        <tag>IT技术</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
